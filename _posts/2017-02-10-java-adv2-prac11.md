---
layout:	post
title:	Java進階 - Practice 11
date:	2017-02-10
categories: java
---

使用JDK NIO.2的函式庫(Files及Path中的方法), 撰寫一個程式能夠從一個模板(template)信件, 產生一系列寄給不同收件者的客製化(custom)信件. 然後利用`walkFileTree()`方法, 從一個目錄路徑將其中的目錄與檔案複製到另一個目錄路徑去. 最後寫一個程式可以遞迴的方式, 搜尋並且刪除符合某的pattern的檔案.

## 11-1 撰寫一個合併檔案內容的程式

使用`Files.readAllLines()`方法, 讀取兩個檔案的內容, 一個檔案是信件模板(form template), 另一個檔案則是包含所有收件人姓名的清單列表. 每次從姓名清單, 讀取一個人名, 然後利用`Files.write()`方法建立這個客製化信件(custom letter). 也將會使用`Pattern`, `Matcher`類別.

### 步驟一:  檢視FormTemplate.txt及NamesList.txt檔案

1. `FormTemplate.txt`是一個樣板信件, 裡面的`<NAME>`將被`NamesList.txt`檔案中的真實姓名所取代. 


### 步驟二:  檢視FormLetterWrite類別

1. main()方法讀取兩個命令列參數, 一個是`FormTemplate.txt`的路徑, 一個是`NamesList.txt`的路徑
1. 利用Files.isRegularFile()檢查傳入的檔案路徑是否是一個存在及一般檔案(不是directory, 或特殊檔案例如symlink, pipe, device等).
1. 建立FileMerge物件, 傳入兩個Path物件
1. 呼叫FileMerge的writeMergedForm()

```java
package com.example;

import com.example.util.FileMerge;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class FormLetterWriter {

    public static void main(String[] args) {
        Path form = null;
        Path list = null;
        // Make sure there are two arguments
        if (args.length < 2) {
            System.out.println("Usage: FormLetter <form template file> <name list file>");
            System.exit(-1);
        }
        // Check that the arguments are file names
        form = Paths.get(args[0]);
        list = Paths.get(args[1]);
        if (!Files.isRegularFile(form) || !Files.isRegularFile(list)) {
            System.out.println("Form template and Name list must be files");
            System.exit(-1);
        }
        // Create an instance of the FormLetter class and then write the forms
        FileMerge fm = new FileMerge(form, list);
        try {
            fm.writeMergedForms();
        } catch (IOException i) {
            System.out.println("Exception: " + i);
        }
    }
}

```

### 步驟三:  FileMerge類別, 

1. 檢視mergeName()及hasToken()方法
  - mergeName(): 使用Pattern物件, 針對一行的文字(傳入的第一個參數), 若包含`<NAME>`pattern, 將之取代為收件人姓名(傳入的第二個參數)
  - hasToken(): 判斷傳入的一行文字(參數), 是否包含`<NAME>`pattern.

1. 撰寫writeMergedForms()方法, 這個方法主要動作是讀取template信件的全部內容, 每一行文字存入到一個`List<String>`物件中(formLetter). 
然後讀取包含寄件人姓名的清單檔案, 也是存入到一個`List<String>`物件中(nameList). 然後針對每一個人名, 從formLetter物件中的每一行文字, 將符合 `<NAME>`pattern的文字取代成這個人名
, 然後寫出這個客製化信件到一個檔案中. 寄件人姓名的清單檔案中包含有10個人名, 因此最後會產生10個客製化信件檔.
  - 外部for迴圈, 迭代每一個nameList中的人名字串
  - 每一個循環中, (1) 產生一個新的`List<String>`物件(customLetter), 用來儲存客製化信件的每一行文字. (2) 替每一個客製化信件訂一個名稱(人名中的空白替換成underscore), 然後產生Path物件 
(3) 定義內部for迴圈, 迭代formLetter中的每一行文字, 呼叫hasToken()方法, 判斷這行文字是否有包含`<NAME>`pattern. 若有matched, 則呼叫mergeName(), 將`<NAME>`pattern, 取代為收件人姓名. 
(4) 將這行文字append到customLetter中. (5) 在外部for迴圈中將customLetter寫到檔案中(利用Files.write()方法)


```java
package com.example.util;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FileMerge {

    private Path form;
    private Path list;
    private String nameToken = "<NAME>";
    private Pattern p = Pattern.compile(nameToken);
    private List<String> formLetter;
    private List<String> customLetter;
    private List<String> nameList;

    public FileMerge(Path form, Path list) {
        this.form = form;
        this.list = list;
    }

    // This method takes the form and merges it with the list
    // It generates new files with the names from the list
    public void writeMergedForms() throws IOException {
        // Open the form letter and read it into the List of Strings
        Charset cs = Charset.defaultCharset();
        formLetter = Files.readAllLines(form, cs);
        // Read in all the names from the names list
        nameList = Files.readAllLines(list, cs);
        // Iterate through the list of names, creating a new customLetter each time
        for (int j = 0; j < nameList.size(); j++) {
            customLetter = new ArrayList<>();
            // Create a new file name from the name in the name list
            String formName = nameList.get(j).replace(' ', '_').concat(".txt");
            Path formOut = form.toRealPath().getParent().resolve(formName);
            for (int k = 0; k < formLetter.size(); k++) {
                if (hasToken(formLetter.get(k))) {
                    customLetter.add(mergeName(formLetter.get(k), nameList.get(j)));
                } else {
                    customLetter.add(formLetter.get(k));
                }
            }
            // Write the customFormLetter out
            Files.write(formOut, customLetter, cs);
            System.out.println("Wrote form letter to: " + nameList.get(j));
        }
    }

    // Produce a new string in the letter that replaces the token with the name
    private String mergeName(String form, String name) {
        Matcher m = p.matcher(form);
        return (m.replaceFirst(name));
    }

    // Determine if the String has the token
    private boolean hasToken(String s) {
        Matcher m = p.matcher(s);
        return m.find();
    }
}
```




:sweat_smile:


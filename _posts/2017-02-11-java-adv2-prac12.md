---
layout:	post
title:	Java進階 - Practice 12
date:	2017-02-11
categories: java
---
 
## 12-1 同步存取共享資料

這的範例是利用多個執行序, 來模擬多個購買者同步做購買的動作. 
多個執行序同時存取一個Store物件, 亦即從Store物件所包含的Shirt集合物件(Deque型態)中移除Shirt物件.
**比較使用及未使用synchronized區塊的差異**. 

### 步驟一: 檢視Store類別

1. Store類別, 代表商店的類別. **這個類別會被多個執行序同時存取, 但是它的成員方法並沒有使用同步控管機制**
  - `Deque`型態的成員變數`shirts`(把deque當作stack來使用): 用來儲存Shirt物件的集合, 代表可以販售的shirt庫存
  - Store型態的靜態變數 instance: 用來作為`Singleton design pattern`實作的唯一Store實體
  - `addShirt(Shirt)`方法: 將Shirt物件加入(push)到`shirts`中
  - `takeShirt()`方法: 將Shirt物件從`shirts`中移除(pop)
  - `getShirtCount()`方法: 取得shirts的元素個數
  - `authorizeCreditCard(String, double)`方法: 模擬連結到外部銀行系統做信用卡認證的流程. 以亂數的方式, 讓這個動作耽誤約1到3秒的時間(呼叫`sleep()`方法)

```java
package com.example;

import java.util.Deque;
import java.util.LinkedList;

public class Store {

    private Deque<Shirt> shirts = new LinkedList<>();
    //singleton
    private static Store instance = new Store();
    //singleton

    private Store() {
    }
    //singleton

    public static Store getInstance() {
        return instance;
    }

    public void addShirt(Shirt shirt) {
        System.out.println("Adding a shirt to the store.");
        shirts.push(shirt);
        System.out.println("Total shirts in stock: " + shirts.size());
    }

    public Shirt takeShirt() {
        return shirts.pop();
    }

    public int getShirtCount() {
        return shirts.size();
    }

    public boolean authorizeCreditCard(String accountNumber, double amount) {
        //placeholder method to test workflow
        //since this would normally communicate with a external source
        //this method should take longer to execute...
        int seconds = (int) (Math.random() * 3 + 1);
        System.out.println("Sleeping for " + seconds + " seconds");
        try {
            Thread.sleep(seconds * 1000);
        } catch (InterruptedException e) {
            System.out.println("Interrupted");
        }
        return true;
    }
}
```


### 步驟二: 撰寫PurchasingAgent類別
1. 代表購買者的類別.
1. 程式執行時的會產生兩個執行序, 每個執行序會產生一個PurchasingAgent物件. 
1. purchase()成員方法: 
  - 列印出執行序的名稱及id
  - 取得Store物件(Store實作Singleton Design Pattern, 因此只有一個Store物件)
  - 模擬購買一件Shirt的動作. 利用`store.getShirtCount()`確認有足夠的shirt庫存, 並且呼叫`store.authorizeCreditCard()`做信用卡驗證. 
以上動作如果成功, 則呼叫`store.takeShirt()`從庫存中移除一件shirt, 然後列印Shirt資訊及成功訊息"The shirt is ours!", 
否則列印失敗訊息"No shirt for you".
1. 執行這個程式數次. 檢視相關的輸出訊息. 注意**輸出訊息每次執行不一樣**. 可能包括:
  - 兩個執行序都顯示成功購買的訊息, 列印兩個相同shirt的內容
  - 兩個執行序都顯示成功購買的訊息, 但僅列印一個shirt的內容, 另一個為null
  - 一個執行序顯示成功購買的訊息, 另一個丟出`java.util.NoSuchElementException`例外事件
  - 一個執行序顯示成功購買的訊息, 另一個顯示失敗的訊息.

```java
package com.example;

public class PurchasingAgent {

    public PurchasingAgent() {
        System.out.println("Creating a purchasing agent");
    }

    public void purchase() {
        Thread t = Thread.currentThread();
        System.out.println("Thread:" + t.getName() + "," + t.getId());
        Store store = Store.getInstance();
        if (store.getShirtCount() > 0 && store.authorizeCreditCard("1234", 15.00)) {
            Shirt shirt = store.takeShirt();
            System.out.println("The shirt is ours!");
            System.out.println(shirt);
        } else {
            System.out.println("No shirt for you");
        }

    }
}
```

### 步驟三: 在PurchasingAgent類別的purchase()使用synchronized區塊

1. 在purchase()方法中增加synchronized區塊, 注意**必須使用共用的store物件作為synchronized block的物件鎖**
1. 這裡不能使用this物件作為物件鎖, 或者將purchase()宣告為synchronized. 
因為每一個thread各自有一個PurchaseAgent物件. 所以並不是共用PurchaseAgent物件. 真正要同步控管的是Store物件的存取. 

```java
package com.example;

public class PurchasingAgent {

    public PurchasingAgent() {
        System.out.println("Creating a purchasing agent");
    }

    public void purchase() {
        Thread t = Thread.currentThread();
        System.out.println("Thread:" + t.getName() + "," + t.getId());
        Store store = Store.getInstance();
        synchronized (store) {
            if (store.getShirtCount() > 0 && store.authorizeCreditCard("1234", 15.00)) {
                Shirt shirt = store.takeShirt();
                System.out.println("The shirt is ours!");
                System.out.println(shirt);
            } else {
                System.out.println("No shirt for you");
            }
        }

    }
}
```

其他程式: SynchronizedMain類別:

```java
package com.example;

public class SynchronizedMain {

    public static void main(String[] args) {
        Store store = Store.getInstance();
        store.addShirt(new Shirt("1", "Polo", "Rainbow", "Large"));
        
        PracticeThread p1 = new PracticeThread();
        PracticeThread p2 = new PracticeThread(); 
        p1.start();
        p2.start();
    }
}
```

PracticeThread類別:

```java
package com.example;

public class PracticeThread extends Thread {
    
    @Override
    public void run() {
        PurchasingAgent agent = new PurchasingAgent();
        agent.purchase();
    }
    
}
```

Shirt類別:

```java
package com.example;

public class Shirt{

    private String id = "";
    private String description = "";
    private String color = "";
    private String size="";

    private Shirt() { };

    public Shirt (String id, String description, String color, String size){
        this.id = id;
        this.description = description;
        this.color = color;
        this.size = size;
    }

    public String getId(){
        return this.id;
    }
    
    public String getDescription() {
        return description;
    }

    public String getColor() {
        return color;
    }
   
    public String getSize() {
        return size;
    }

    @Override
    public String toString(){
        StringBuilder sb = new StringBuilder();
        sb.append("Shirt ID: ");
        sb.append(getId());
        sb.append("\nDescription: ");
        sb.append(getDescription());
        sb.append("\nColor: ");
        sb.append(getColor());
        sb.append("\nSize: ");
        sb.append(this.getSize());
        sb.append("\n");

        return sb.toString();
    }
}
```

:sweat_smile:

